<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wrong Way 88 â€” 8â€‘bit Motorway</title>
<style>
  :root{
    --bg:#060606; --ink:#ff1a2d; --dim:#7a0d16; --road:#151515; --lane:#2a2a2a; --coin:#ff4040; --box:#a30017;
    --hud:#0c0c0c; --hudBorder:#2a0006; --white:#f8f8f8;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--white);font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Cascadia Mono", "Roboto Mono", monospace;}
  .wrap{display:grid;place-items:center;min-height:100%}
  .frame{position:relative;width:min(94vw,980px);height:min(80vh,700px);max-height:95vh;border:3px solid var(--ink);box-shadow:0 0 0 6px #000 inset, 0 0 40px rgba(255,0,24,.25);background:#000;border-radius:10px;overflow:hidden}
  canvas{position:absolute;inset:0;width:100%;height:100%;image-rendering: pixelated;image-rendering: crisp-edges}
  .hud{position:absolute;left:8px;top:8px;display:flex;gap:8px;align-items:center}
  .card{background:var(--hud);border:2px solid var(--hudBorder);padding:6px 10px;border-radius:6px;color:var(--ink);font-weight:700}
  .card span{color:#fff}
  .right{position:absolute;right:8px;top:8px;display:flex;gap:8px}
  button{cursor:pointer;background:var(--hud);border:2px solid var(--hudBorder);color:#fff;font-weight:800;padding:6px 10px;border-radius:6px}
  .help{position:absolute;left:50%;transform:translateX(-50%);bottom:8px;background:var(--hud);border:2px solid var(--hudBorder);padding:6px 10px;border-radius:6px;color:#bbb;text-align:center}
  .kbd{display:inline-block;min-width:1.6ch;padding:0 .3rem;border:2px solid var(--hudBorder);border-radius:4px;background:#111;color:#fff}
  .title{position:absolute;inset:0;display:grid;place-items:center;background:radial-gradient(ellipse at center, rgba(255,0,32,.15), transparent 60%);}
  .title .card{font-size:clamp(22px,3.2vw,40px);text-align:center;color:#fff;border-color:var(--ink)}
  .title small{display:block;margin-top:6px;color:#bbb}
  .bar{height:10px;background:#220006;border:2px solid var(--hudBorder);border-radius:4px;overflow:hidden}
  .bar > i{display:block;height:100%;background:var(--ink);width:0%}
  .speedo{display:flex;align-items:center;gap:6px}
  .speedo .ticks{display:grid;grid-auto-flow:column;gap:2px}
  .tick{width:6px;height:10px;background:#220006;border:1px solid #3a0008}
  .tick.on{background:var(--ink);border-color:var(--ink)}
  .toast{position:absolute;left:50%;top:10%;transform:translateX(-50%);background:#000a;border:2px solid var(--ink);padding:6px 10px;border-radius:6px;opacity:0;transition:.2s}
  .toast.show{opacity:1}
</style>
</head>
<body>
  <div class="wrap">
    <div class="frame">
      <canvas id="game" width="320" height="180" aria-label="Wrong Way 88 game area"></canvas>
      <div class="hud">
        <div class="card">Score: <span id="score">0</span></div>
        <div class="card">High: <span id="hi">0</span></div>
        <div class="card speedo">
          <span>SPEED</span>
          <div class="ticks" id="speedTicks"></div>
        </div>
        <div class="card" style="min-width:180px">
          BOOST
          <div class="bar"><i id="boostFill"></i></div>
        </div>
      </div>
      <div class="right">
        <button id="muteBtn" title="Mute/Unmute">ðŸ”Š</button>
        <button id="restartBtn" title="Restart">â†»</button>
      </div>
      <div class="help">
        <b>Controls</b> â€” <span class="kbd">A</span>/<span class="kbd">D</span> steer Â·
        <span class="kbd">S</span> brake (hold + steer = drift) Â·
        <span class="kbd">W</span> boost Â· autoâ€‘accel
      </div>
      <div class="toast" id="toast">+3s BOOST</div>
      <div class="title" id="title">
        <div class="card">
          <div style="color:var(--ink);font-weight:900;letter-spacing:1px;">WRONG WAY 88</div>
          <small>Birdâ€™sâ€‘eye 8â€‘bit motorway. Black & red. Avoid oncoming traffic. Drift to earn boost. Coins, lucky boxes, billboards.</small>
          <small>Press <span class="kbd">W</span> / any key to start.</small>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Canvas (low-res; auto-scaled for chunky pixels) =====
  const c = document.getElementById('game');
  const ctx = c.getContext('2d', { alpha:false });
  const W = c.width, H = c.height;
  ctx.imageSmoothingEnabled = false;

  // ===== UI nodes =====
  const scoreEl = document.getElementById('score');
  const hiEl = document.getElementById('hi');
  const boostFill = document.getElementById('boostFill');
  const title = document.getElementById('title');
  const toast = document.getElementById('toast');
  const restartBtn = document.getElementById('restartBtn');
  const muteBtn = document.getElementById('muteBtn');
  const speedTicks = document.getElementById('speedTicks');
  for(let i=0;i<12;i++){ const d=document.createElement('i'); d.className='tick'; speedTicks.appendChild(d); }
  const tickEls = Array.from(document.querySelectorAll('.tick'));

  // ===== Palette =====
  const COL = {
    bg:"#060606", red:"#ff1a2d", dim:"#7a0d16", road:"#151515", lane:"#2a2a2a",
    coin:"#ff4040", box:"#a30017", white:"#f8f8f8", smoke:"#aa000f"
  };

  // ===== Audio (chiptune + sfx) =====
  let AC, master, musicGain, sfxGain, musicNodes=[], muted=false;
  function initAudio(){
    if(AC) return;
    AC = new (window.AudioContext||window.webkitAudioContext)();
    master = AC.createGain(); master.gain.value = 0.9; master.connect(AC.destination);
    musicGain = AC.createGain(); musicGain.gain.value = 0.25; musicGain.connect(master);
    sfxGain = AC.createGain(); sfxGain.gain.value = 0.35; sfxGain.connect(master);
    startMusic();
  }
  function note(freq, time, dur, type='square', vol=0.2){
    const o=AC.createOscillator(), g=AC.createGain();
    o.type=type; o.frequency.value=freq; g.gain.value=vol;
    o.connect(g).connect(sfxGain);
    o.start(time); g.gain.setValueAtTime(vol,time);
    g.gain.exponentialRampToValueAtTime(0.0001, time+dur);
    o.stop(time+dur+0.02);
  }
  function noiseBurst(time=AC.currentTime, dur=0.2, vol=0.25){
    const b=AC.createBuffer(1, AC.sampleRate*dur, AC.sampleRate);
    const d=b.getChannelData(0);
    for(let i=0;i<d.length;i++){ d[i]=(Math.random()*2-1)*(1-i/d.length); }
    const s=AC.createBufferSource(); const g=AC.createGain();
    g.gain.value=vol; s.buffer=b; s.connect(g).connect(sfxGain);
    s.start(time);
  }
  function sfxCoin(){ if(!AC||muted) return; const t=AC.currentTime; note(800,t,.06); note(1200,t+.06,.05); }
  function sfxBoxGood(){ if(!AC||muted) return; const t=AC.currentTime; note(500,t,.05); note(900,t+.05,.05); note(1300,t+.10,.08); }
  function sfxCrash(){ if(!AC||muted) return; noiseBurst(AC.currentTime,.25,.35); }
  function sfxDrift(){ if(!AC||muted) return; const t=AC.currentTime; note(160,t,.04,'triangle',0.15); }
  function startMusic(){
    // Simple 80s-ish arpeggio loop
    const t0 = AC.currentTime + 0.05;
    const tempo = 110; // bpm
    const beat = 60/tempo;
    const scale = [220, 277, 330, 392]; // A minor-ish
    for(let bar=0; bar<8; bar++){
      for(let s=0; s<16; s++){
        const time = t0 + (bar*16 + s)*beat/2;
        const f = scale[(s%4)];
        const o=AC.createOscillator(), g=AC.createGain();
        o.type='square'; o.frequency.value=f* (s%8<4?1:2);
        g.gain.value=0.08;
        o.connect(g).connect(musicGain);
        o.start(time);
        g.gain.exponentialRampToValueAtTime(0.0001, time+beat*0.45);
        o.stop(time+beat*0.5);
      }
      // kickish blip
      for(let k=0;k<4;k++){
        const time = t0 + (bar*4 + k)*beat;
        const o=AC.createOscillator(), g=AC.createGain();
        o.type='sine'; o.frequency.setValueAtTime(120,time);
        o.frequency.exponentialRampToValueAtTime(60, time+0.05);
        g.gain.value=0.18; o.connect(g).connect(musicGain);
        o.start(time); g.gain.exponentialRampToValueAtTime(0.0001,time+0.08); o.stop(time+0.1);
      }
    }
    // schedule refresh
    setTimeout(()=>{ if(AC && !muted) startMusic(); }, (8*16*beat/2)*1000 - 200);
  }
  muteBtn.onclick = () => {
    muted=!muted;
    if(!AC){ initAudio(); }
    master.gain.value = muted ? 0 : 0.9;
    muteBtn.textContent = muted ? "ðŸ”‡" : "ðŸ”Š";
  };

  // ===== Input =====
  const keys = new Set();
  const onKey = (e,down) => {
    const code = e.code;
    if(["KeyA","KeyD","KeyS","KeyW","ArrowLeft","ArrowRight","Space","Enter"].includes(code)){
      e.preventDefault();
    }
    if(down) keys.add(code); else keys.delete(code);
    if(down && !state.started){
      state.started = true; state.paused = false; title.style.display='none';
      initAudio(); if(AC && AC.state === 'suspended') AC.resume();
    }
  };
  addEventListener('keydown', e=>onKey(e,true));
  addEventListener('keyup', e=>onKey(e,false));
  restartBtn.onclick = ()=> reset();

  // ===== Game state =====
  const MAX_BOOST = 10.0; // seconds cap
  function reset(){
    state = {
      started:false, paused:true, over:false,
      player: { x: W/2, y:H-24, vx:0, laneW: W*0.42, drift:false, driftDir:0, driftTrail:[] },
      speed: 90, // px/s world speed
      baseSpeed: 90, // increases slowly
      boost: 0, // seconds
      boosting:false, boostLock:0,
      score:0, hi: Number(localStorage.getItem('ww88_hi')||0),
      spawnT:0, coinT:0, bbT:0, overheadT:3, boxT:5,
      cars:[], coins:[], boxes:[], billboards:[], gantries:[],
      roadY:0
    };
    updateHud();
    title.style.display='';
  }
  let state; reset();

  // ===== Helpers =====
  const rand=(a,b)=>Math.random()*(b-a)+a;
  const rint=(a,b)=>Math.floor(rand(a,b+1));
  const clamp=(v,a,b)=>v<a?a:(v>b?b:v);

  // ===== Spawning =====
  function spawn(dt){
    state.spawnT -= dt;
    state.coinT -= dt;
    state.bbT -= dt;
    state.overheadT -= dt;
    state.boxT -= dt;

    const laneLeft = (W - state.player.laneW) / 2;
    const lanes = 5;
    const laneSize = state.player.laneW / lanes;

    if(state.spawnT<=0){
      // Oncoming car in random lane
      const lane = rint(0,lanes-1);
      const x = laneLeft + laneSize*(lane+0.5);
      const s = rand(120,180) * (1 + state.score/400); // gets tougher
      state.cars.push({x, y:-30, speed:s, w:18, h:26});
      state.spawnT = clamp(0.9 - state.score/250, 0.25, 0.9);
    }
    if(state.coinT<=0){
      const lane = rint(0,lanes-1);
      const x = laneLeft + laneSize*(lane+0.5);
      state.coins.push({x, y:-20});
      state.coinT = rand(0.5, 1.2);
    }
    if(state.boxT<=0){
      const lane = rint(0,lanes-1);
      const x = laneLeft + laneSize*(lane+0.5);
      state.boxes.push({x, y:-20, t:0});
      state.boxT = rand(4,7);
    }
    if(state.bbT<=0){
      // roadside billboard
      const side = Math.random()<0.5 ? -1 : 1;
      state.billboards.push({side, y:-50, x: side<0 ? laneLeft-18 : laneLeft+state.player.laneW+18, txt: randomAd(), overhead:false});
      state.bbT = rand(1.2, 2.2);
    }
    if(state.overheadT<=0){
      // overhead gantry ad
      state.gantries.push({y:-10, txt: randomAd()});
      state.overheadT = rand(6,10);
    }
  }

  function randomAd(){
    const ads = [
      "WALKMAN", "VHS MAX", "NEON COLA", "HIâ€‘FI 2000", "SYNTHWAVE", "LASER DISC",
      "8â€‘BIT BITES", "CASSETTE PRO", "REDLINE OIL", "ARCADE CLUB", "BOOMBOX", "PAGER"
    ];
    return ads[rint(0,ads.length-1)];
  }

  // ===== Logic =====
  function update(dt){
    if(state.paused || !state.started || state.over) return;

    // Base speed creeps up
    state.baseSpeed = clamp(state.baseSpeed + dt*2, 90, 180);

    // Input
    const left = keys.has('KeyA') || keys.has('ArrowLeft');
    const right = keys.has('KeyD') || keys.has('ArrowRight');
    const brake = keys.has('KeyS');
    const wantBoost = keys.has('KeyW');

    // Drift
    const driftNow = brake && (left || right);
    if(driftNow && !state.player.drift){
      sfxDrift();
    }
    state.player.drift = driftNow;
    state.player.driftDir = driftNow ? (left?-1:1) : 0;

    // Boost mechanic
    if(driftNow){
      state.boost = clamp(state.boost + dt, 0, MAX_BOOST); // 1ms drift = 1ms boost
    }
    // Boosting only while holding W and have charge (unless boostLock active)
    if(state.boost>0 && wantBoost && state.boostLock<=0){
      state.boosting = true;
      state.boost -= dt;
    } else {
      state.boosting = false;
    }
    // Pull out of boost by decelerating (brake sets a short lock)
    if(state.boosting && brake){
      state.boosting = false;
      state.boostLock = 0.35; // half a beat
    }
    state.boostLock = Math.max(0, state.boostLock - dt);

    // Lateral movement
    const laneLeft = (W - state.player.laneW) / 2;
    const lanes = 5;
    const laneSize = state.player.laneW / lanes;
    const maxXLeft = laneLeft + 6;
    const maxXRight = laneLeft + state.player.laneW - 6;

    const lateralBase = 110; // px/s
    let lateral = lateralBase * (state.boosting?1.15:1.0) * (brake?0.7:1);
    if(driftNow) lateral *= 1.25; // snappier while drifting

    if(left) state.player.x -= lateral * dt;
    if(right) state.player.x += lateral * dt;
    state.player.x = clamp(state.player.x, maxXLeft, maxXRight);

    // World scroll speed
    const speed = (state.baseSpeed + (state.boosting?80:0) - (brake?40:0));
    state.speed = speed;

    // Road phase
    state.roadY = (state.roadY + speed*dt) % 20;

    // Entities descend
    const moveList = (arr, vyMul=1)=> {
      for(let i=arr.length-1;i>=0;i--){
        const o=arr[i]; o.y += (speed * dt * vyMul);
        if(o.y > H+40) arr.splice(i,1);
      }
    };
    moveList(state.cars, 1.0);
    moveList(state.coins, 1.0);
    moveList(state.boxes, 1.0);
    for(let i=state.billboards.length-1;i>=0;i--){
      const b=state.billboards[i]; b.y += speed*dt*0.65; if(b.y>H+60) state.billboards.splice(i,1);
    }
    for(let i=state.gantries.length-1;i>=0;i--){
      const g=state.gantries[i]; g.y += speed*dt*0.9; if(g.y>H+40) state.gantries.splice(i,1);
    }

    // Collision helpers (rough AABB)
    function hitRect(ax,ay,aw,ah,bx,by,bw,bh){
      return Math.abs(ax-bx) < (aw/2 + bw/2) && Math.abs(ay-by) < (ah/2 + bh/2);
    }

    // Player "sprite" rect
    const pw=14, ph=22, px = state.player.x, py = state.player.y;

    // Coins
    for(let i=state.coins.length-1;i>=0;i--){
      const coin=state.coins[i];
      if(hitRect(px,py,pw,ph, coin.x, coin.y, 8, 8)){
        state.coins.splice(i,1);
        state.score += 1;
        sfxCoin();
      }
    }

    // Lucky boxes (boost or coins)
    for(let i=state.boxes.length-1;i>=0;i--){
      const box=state.boxes[i];
      box.t += dt;
      if(hitRect(px,py,pw,ph, box.x, box.y, 10, 10)){
        state.boxes.splice(i,1);
        if(Math.random()<0.55){
          state.boost = clamp(state.boost + 3, 0, MAX_BOOST);
          toastMsg("+3s BOOST");
          sfxBoxGood();
        } else {
          const add = rint(2,5);
          state.score += add;
          toastMsg("+"+add+" COINS");
          sfxCoin();
        }
      }
    }

    // Cars (crash)
    for(const car of state.cars){
      if(hitRect(px,py,pw,ph, car.x, car.y, car.w, car.h)){
        sfxCrash();
        gameOver();
        break;
      }
    }

    updateHud();

    // Spawn waves
    spawn(dt);

    // Leave drift tracks
    if(state.player.drift){
      state.player.driftTrail.push({x: px-4*state.player.driftDir, y: py+8, a: 1.0});
      if(state.player.driftTrail.length>50) state.player.driftTrail.shift();
    }
    // Fade trails
    for(let i=state.player.driftTrail.length-1;i>=0;i--){
      const t=state.player.driftTrail[i];
      t.a -= dt*1.8;
      if(t.a<=0) state.player.driftTrail.splice(i,1);
    }
  }

  function gameOver(){
    state.over=true; state.paused=true;
    if(state.score>state.hi){
      state.hi = state.score;
      localStorage.setItem('ww88_hi', state.hi);
    }
    title.style.display='';
    title.querySelector('.card').innerHTML =
      `<div style="color:${COL.red};font-weight:900;letter-spacing:1px;">CRASHED</div>
       <small>Score: ${state.score} Â· High: ${state.hi}</small>
       <small>Press <span class="kbd">â†µ</span> / any key to retry.</small>`;
  }

  function updateHud(){
    scoreEl.textContent = state.score;
    hiEl.textContent = state.hi;

    // Boost bar
    const pct = (state.boost/MAX_BOOST)*100;
    boostFill.style.width = pct.toFixed(1)+'%';

    // Speed ticks (12)
    const sNorm = clamp((state.speed-60)/140, 0, 1);
    const on = Math.round(sNorm * tickEls.length);
    tickEls.forEach((t,i)=> t.className = 'tick'+(i<on?' on':''));
  }

  function toastMsg(txt){
    toast.textContent = txt;
    toast.classList.add('show');
    clearTimeout(toastMsg._t);
    toastMsg._t = setTimeout(()=>toast.classList.remove('show'), 700);
  }

  // ===== Drawing =====
  function draw(){
    // Clear
    ctx.fillStyle = COL.bg;
    ctx.fillRect(0,0,W,H);

    // Road area
    const laneW = state.player.laneW;
    const roadX = (W - laneW)/2;
    ctx.fillStyle = COL.road;
    ctx.fillRect(roadX, 0, laneW, H);

    // Lane lines (scroll)
    ctx.fillStyle = COL.lane;
    const segH = 20;
    let yOff = (H - (state.roadY % segH));
    for(let i=0;i< Math.ceil(H/segH)+1;i++){
      // centerlines
      const yy = yOff - i*segH;
      for(let l=1; l<5; l++){
        const x = roadX + (laneW/5)*l - 1;
        ctx.fillRect(x, yy, 2, 10);
      }
    }

    // Billboards roadside
    for(const b of state.billboards){
      drawBillboard(b);
    }
    // Overhead gantry
    for(const g of state.gantries){
      drawGantry(g);
    }

    // Coins
    for(const coin of state.coins){
      drawCoin(coin);
    }
    // Boxes
    for(const box of state.boxes){
      drawBox(box);
    }

    // Cars
    for(const car of state.cars){
      drawCar(car);
    }

    // Drift tracks
    for(const t of state.player.driftTrail){
      ctx.globalAlpha = Math.max(0, Math.min(1, t.a))*0.8;
      ctx.fillStyle = COL.smoke;
      ctx.fillRect(Math.round(t.x), Math.round(t.y), 2, 4);
      ctx.globalAlpha = 1;
    }

    // Player bike (top-down, black+red)
    drawBike(state.player.x, state.player.y, state.player.drift ? state.player.driftDir : 0);

    // Debug (optional)
    // ctx.fillStyle='#0f0'; ctx.fillRect(state.player.x-7, state.player.y-11, 14, 22);
  }

  function drawBike(x,y,tilt){
    // tyres
    ctx.fillStyle = "#101010";
    ctx.fillRect(Math.round(x-4), Math.round(y-12), 8, 6);
    ctx.fillRect(Math.round(x-4), Math.round(y+6), 8, 6);
    // body
    ctx.fillStyle = COL.red;
    ctx.fillRect(Math.round(x-3), Math.round(y-6), 6, 14);
    // bars
    ctx.fillRect(Math.round(x-8), Math.round(y-8), 16, 2);
    // visor (driver)
    ctx.fillStyle = "#2a0006";
    ctx.fillRect(Math.round(x-2), Math.round(y-2), 4, 3);
    // blink tilt via small side pixel
    if(tilt!==0){
      ctx.fillStyle = COL.dim;
      ctx.fillRect(Math.round(x + tilt*5), Math.round(y-5), 2, 10);
    }
  }
  function drawCar(o){
    ctx.fillStyle = COL.red;
    ctx.fillRect(Math.round(o.x-9), Math.round(o.y-13), 18, 26);
    ctx.fillStyle = COL.dim;
    ctx.fillRect(Math.round(o.x-7), Math.round(o.y-9), 14, 8);
    ctx.fillStyle = "#101010";
    ctx.fillRect(Math.round(o.x-8), Math.round(o.y-12), 16, 4);
    ctx.fillRect(Math.round(o.x-8), Math.round(o.y+8), 16, 4);
  }
  function drawCoin(o){
    ctx.fillStyle = COL.coin;
    ctx.fillRect(Math.round(o.x-3), Math.round(o.y-3), 6, 6);
    ctx.fillStyle = "#80000b";
    ctx.fillRect(Math.round(o.x-1), Math.round(o.y-1), 2, 2);
  }
  function drawBox(o){
    // Lucky box with blinking "?"
    ctx.fillStyle = COL.box;
    ctx.fillRect(Math.round(o.x-5), Math.round(o.y-5), 10, 10);
    const blink = (Math.floor(o.t*6)%2)===0;
    if(blink){
      ctx.fillStyle = COL.red;
      ctx.fillRect(Math.round(o.x-1), Math.round(o.y-3), 2, 2);
      ctx.fillRect(Math.round(o.x-1), Math.round(o.y), 2, 2);
      ctx.fillRect(Math.round(o.x-1), Math.round(o.y+3), 2, 2);
    }
  }
  function drawBillboard(b){
    // simple rectangle + text
    ctx.fillStyle = COL.box;
    const w=34, h=18;
    ctx.fillRect(Math.round(b.x - (b.side<0?w:0)), Math.round(b.y), w, h);
    // feet
    ctx.fillStyle = "#220006";
    const px = b.side<0 ? b.x - 2 : b.x + 2;
    ctx.fillRect(Math.round(px), Math.round(b.y+h), 2, 6);
    // text
    ctx.fillStyle = COL.white;
    tinyText(b.side<0 ? Math.round(b.x - w + 3) : Math.round(b.x+3), Math.round(b.y+6), b.txt);
  }
  function drawGantry(g){
    // bar across road
    const laneW = state.player.laneW;
    const roadX = (W - laneW)/2;
    ctx.fillStyle = "#220006";
    ctx.fillRect(roadX-8, Math.round(g.y)+10, laneW+16, 4);
    // sign in the middle
    const w=60,h=14;
    ctx.fillStyle = COL.box;
    ctx.fillRect(Math.round(W/2 - w/2), Math.round(g.y), w, h);
    ctx.fillStyle = COL.white;
    tinyText(Math.round(W/2 - w/2 + 6), Math.round(g.y+4), g.txt);
  }

  // 4x6 pixel text renderer (very tiny)
  function tinyText(x,y,txt){
    ctx.fillStyle = COL.white;
    const s = 1; // scale
    for(let i=0;i<txt.length;i++){
      const ch = txt[i].toUpperCase();
      drawChar(x + i*5*s, y, ch, s);
    }
  }
  function drawChar(x,y,ch,s){
    // Simple set for A-Z 0-9 - we'll fake with rectangles for style
    const w=3*s,h=5*s;
    // draw as blocky columns based on charcode hash
    const code = ch.charCodeAt(0);
    for(let cx=0; cx<3; cx++){
      for(let cy=0; cy<5; cy++){
        // hashed pixel pattern for retro feel
        const on = ((code + cx*7 + cy*11) % 5) < 3;
        if(on) ctx.fillRect(x+cx*s, y+cy*s, s, s);
      }
    }
  }

  // ===== Loop =====
  let last = performance.now();
  function frame(t){
    const dt = Math.min(0.05, (t-last)/1000); last=t;
    if(!state.paused && state.started && !state.over){
      update(dt);
    }
    draw();
    // handle pressed Enter to restart on game over
    if(state.over && (keys.has('Enter') || keys.has('Space'))){
      reset();
    }
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
